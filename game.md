# Давайте подробно разберём файл **game.py**. 
Именно здесь начинается жизнь нашей игры: здесь создаётся холст, добавляются объекты (птица и трубы), обрабатываются нажатия клавиш, обновляется состояние игры и проверяются столкновения. Мы будем идти строго по коду, чтобы понять, как всё устроено.

---

## **1. Импорт нужных модулей и констант**

В начале файла находятся импорты:

```python
import tkinter as tk
import time
from bird import Bird
from pipe import Pipe
from constants import WINDOW_WIDTH, WINDOW_HEIGHT, PIPE_INTERVAL, PIPE_WIDTH
```

- **`import tkinter as tk`**  
  Импортируем модуль Tkinter для создания графического интерфейса. Всё, что связано с графикой (окно, холст, изображения), будет работать через этот модуль.

- **`import time`**  
  Модуль `time` нужен для работы с временем. Мы будем использовать его для определения интервалов между появлением труб и для управления анимацией.

- **`from bird import Bird`**  
  Импортируем класс `Bird` из файла `bird.py`. Этот класс отвечает за поведение птицы (её изображение, прыжки, гравитацию).

- **`from pipe import Pipe`**  
  Импортируем класс `Pipe` из файла `pipe.py`. Этот класс создаёт трубы, через которые нужно пролетать птице.

- **`from constants import WINDOW_WIDTH, WINDOW_HEIGHT, PIPE_INTERVAL, PIPE_WIDTH`**  
  Импортируем константы из файла `constants.py`. Константы – это фиксированные значения, которые мы будем использовать во всей игре (размер окна, интервал между трубами, ширина труб).

---

## **2. Класс Game – сердце игры**

Весь код игры оформлен в классе `Game`. Когда мы создаём новый объект `Game`, он настраивает всё: окно, счёт, объекты игры и обработку событий.

```python
class Game:
    def __init__(self, root):
```

### **Метод `__init__(self, root)`**

Это конструктор класса, он вызывается автоматически, когда мы создаём игру. Он получает один аргумент:
- **`root`** – главное окно (создаётся в `main.py`), в котором будет происходить всё действие.

Давайте пройдёмся по строчкам конструктора:

1. **Настройка окна и создание холста**

   ```python
   self.root = root
   self.root.title("Flappy Bird")
   self.canvas = tk.Canvas(root, width=WINDOW_WIDTH, height=WINDOW_HEIGHT, bg="skyblue")
   self.canvas.pack()
   ```
   - **`self.root = root`**  
     Сохраняем ссылку на главное окно в переменной объекта, чтобы в дальнейшем к нему обращаться.
   - **`self.root.title("Flappy Bird")`**  
     Задаём заголовок окна, чтобы пользователь видел имя игры.
   - **`self.canvas = tk.Canvas(root, width=WINDOW_WIDTH, height=WINDOW_HEIGHT, bg="skyblue")`**  
     Создаём холст, где будут размещаться все игровые элементы (птица, трубы, текст счёта).  
     **Параметры:**
     - `root` – родительский элемент (главное окно).
     - `width` и `height` – размеры холста (константы из `constants.py`).
     - `bg` – цвет фона. Здесь выбран «небесно-голубой», чтобы напоминал небо.
   - **`self.canvas.pack()`**  
     Метод `pack()` размещает холст в окне. Это один из способов управления расположением виджетов в Tkinter.

2. **Инициализация счёта**

   ```python
   self.score = 0
   self.score_text = self.canvas.create_text(10, 10, anchor="nw",
                                              text=f"Score: {self.score}",
                                              font=("Arial", 16), fill="black")
   ```
   - **`self.score = 0`**  
     Устанавливаем начальное значение счёта.
   - **`self.canvas.create_text(...)`**  
     Рисуем текст на холсте.  
     **Параметры:**
     - Координаты `(10, 10)` – позиция текста (отступ от левого верхнего угла).
     - `anchor="nw"` – якорь, определяющий, что позиция (10, 10) соответствует левому верхнему углу текста.
     - `text=f"Score: {self.score}"` – текст, который будет отображаться (текущий счёт).
     - `font=("Arial", 16)` – шрифт и размер текста.
     - `fill="black"` – цвет текста.

3. **Загрузка лучшего результата**

   ```python
   self.best_score = self.load_best_score()
   ```
   Вызывается метод `load_best_score()`, который пытается прочитать лучший результат из файла. Это нужно для того, чтобы сохранять достижения игрока между запусками игры.

4. **Создание объектов птицы и труб**

   ```python
   self.bird = Bird(self.canvas)
   self.pipes = []
   self.last_pipe_time = time.time() * 1000
   ```
   - **`self.bird = Bird(self.canvas)`**  
     Создаём объект птицы. Передаём в него холст, чтобы он знал, где рисовать своё изображение.
   - **`self.pipes = []`**  
     Инициализируем список для хранения труб. Сначала он пуст, так как трубы будут появляться по ходу игры.
   - **`self.last_pipe_time = time.time() * 1000`**  
     Записываем время создания игры в миллисекундах. Это нужно для расчёта, когда создавать новую трубу (интервалы между трубами задаются константой `PIPE_INTERVAL`).

5. **Инициализация состояния игры**

   ```python
   self.game_over = False
   ```
   Флаг `game_over` показывает, закончилась ли игра. В начале игры он равен `False`.

6. **Обработка ввода пользователя**

   ```python
   self.root.bind("<space>", self.handle_input)
   self.root.bind("<Button-1>", self.handle_input)
   ```
   - **`self.root.bind("<space>", self.handle_input)`**  
     Связываем нажатие клавиши пробел с вызовом метода `handle_input`. То есть, когда игрок нажимает пробел, будет вызвана функция `handle_input`.
   - **`self.root.bind("<Button-1>", self.handle_input)`**  
     Аналогично, связываем клик мыши с тем же методом. Это даёт альтернативу для управления птицей.

7. **Запуск обновления игры**

   ```python
   self.update()
   ```
   Вызываем метод `update()`, который отвечает за постоянное обновление состояния игры – перемещение объектов, появление новых труб, проверку столкновений и т.д.  
   Этот метод будет вызываться снова и снова с помощью `self.root.after()`, что создаёт эффект анимации.

---

## **3. Методы класса Game**

### **Метод: `load_best_score(self)`**

```python
def load_best_score(self):
    try:
        with open("score.txt", "r") as f:
            return int(f.read())
    except FileNotFoundError:
        return 0
```

- **Назначение:**  
  Этот метод пытается открыть файл `score.txt` и прочитать оттуда лучший результат (наибольшее количество очков). Если файла нет, возвращает 0.
  
- **Как работает:**  
  Используется конструкция `try...except`:
  - Если файл найден, читаем его содержимое, преобразуем в целое число и возвращаем.
  - Если файла нет (`FileNotFoundError`), возвращаем 0.

### **Метод: `save_best_score(self)`**

```python
def save_best_score(self):
    with open("score.txt", "w") as f:
        f.write(str(self.best_score))
```

- **Назначение:**  
  Сохраняет лучший результат в файл `score.txt`.  
- **Как работает:**  
  Открываем файл в режиме записи (`"w"`), записываем туда значение `self.best_score` (преобразованное в строку).

### **Метод: `handle_input(self, event)`**

```python
def handle_input(self, event):
    if not self.game_over:
        self.bird.jump()
    else:
        self.restart()
```

- **Назначение:**  
  Обрабатывает ввод от пользователя (нажатие клавиши пробел или клик мышью).
  
- **Параметры:**  
  - **`event`** – объект события, который содержит информацию о том, что произошло (например, какая клавиша нажата). Здесь он не используется напрямую, но его нужно передать, чтобы метод можно было связать с событием.

- **Как работает:**  
  - Если игра ещё не закончилась (`self.game_over` равен `False`), вызываем метод `jump()` у птицы – это заставит птицу подпрыгнуть.
  - Если игра закончилась, вместо прыжка запускаем метод `restart()`, который перезапускает игру.

### **Метод: `update(self)`**

```python
def update(self):
    if self.game_over:
        return

    self.bird.update()

    now = time.time() * 1000  # текущее время в мс
    if now - self.last_pipe_time > PIPE_INTERVAL:
        self.pipes.append(Pipe(self.canvas))
        self.last_pipe_time = now

    # Обновляем трубы и проверяем, прошла ли птица мимо трубы
    for pipe in self.pipes:
        pipe.update()
        # Если правая сторона трубы прошла левую сторону птицы и счёт ещё не увеличен
        if not pipe.scored and pipe.x + PIPE_WIDTH < self.bird.x:
            self.score += 1
            pipe.scored = True
            self.canvas.itemconfig(self.score_text, text=f"Score: {self.score}")

    # Удаляем трубы, вышедшие за экран
    self.pipes = [pipe for pipe in self.pipes if not pipe.off_screen()]

    if self.check_collisions():
        self.end_game()
        return

    self.root.after(20, self.update)
```

- **Назначение:**  
  Этот метод – главный цикл игры. Он обновляет положение объектов, создаёт новые трубы, проверяет столкновения и обновляет счёт.

- **Основные шаги метода:**
  1. **Проверка состояния игры:**  
     Если игра закончена (`self.game_over` равен `True`), метод прекращает работу (выходит с помощью `return`).
  
  2. **Обновление птицы:**  
     `self.bird.update()` – метод из класса `Bird`, который обновляет положение птицы (учитывает гравитацию, изменяет координаты).
  
  3. **Создание новых труб:**  
     Получаем текущее время (`now`) в миллисекундах. Если с момента создания последней трубы прошло больше времени, чем задано в `PIPE_INTERVAL`, создаём новую трубу:
     ```python
     self.pipes.append(Pipe(self.canvas))
     self.last_pipe_time = now
     ```
  
  4. **Обновление труб и начисление очков:**  
     Для каждой трубы в списке:
     - Вызывается `pipe.update()`, который перемещает трубу влево.
     - Если труба прошла птицу (проверка по координатам: `pipe.x + PIPE_WIDTH < self.bird.x`), и счёт за эту трубу ещё не начислен (`pipe.scored` – False), увеличиваем счёт и меняем текст на холсте.
  
  5. **Удаление вышедших за экран труб:**  
     Создаётся новый список труб, в котором остаются только те, которые ещё не ушли за левую границу экрана. Для этого вызывается метод `pipe.off_screen()`.
  
  6. **Проверка столкновений:**  
     Вызываем метод `check_collisions()`, который возвращает `True`, если птица столкнулась с трубой или вышла за границы окна. Если столкновение произошло, вызываем `self.end_game()` и прекращаем обновление.
  
  7. **Планирование следующего обновления:**  
     Метод `self.root.after(20, self.update)` говорит Tkinter: "Подожди 20 миллисекунд и вызови метод `update()` снова". Это создаёт цикл, который обновляет игру примерно 50 раз в секунду.

### **Метод: `check_collisions(self)`**

```python
def check_collisions(self):
    bird_bbox = self.bird.get_bbox()
    if bird_bbox[1] < 0 or bird_bbox[3] > WINDOW_HEIGHT:
        return True

    for pipe in self.pipes:
        upper_coords = self.canvas.coords(pipe.upper_pipe_id)
        lower_coords = self.canvas.coords(pipe.lower_pipe_id)
        if self.rect_overlap(bird_bbox, upper_coords) or self.rect_overlap(bird_bbox, lower_coords):
            return True
    return False
```

- **Назначение:**  
  Проверяет, столкнулась ли птица с чем-либо (с трубами или с границами экрана).

- **Как работает:**  
  1. **Получаем границы птицы:**  
     `bird_bbox = self.bird.get_bbox()` возвращает список координат `[x1, y1, x2, y2]`, которые описывают прямоугольник, занимаемый птицей.
  2. **Проверка выхода за пределы экрана:**  
     Если верхняя координата меньше 0 (выше экрана) или нижняя координата больше `WINDOW_HEIGHT` (ниже экрана), возвращаем `True` – столкновение.
  3. **Проверка столкновения с трубами:**  
     Для каждой трубы получаем координаты верхней и нижней труб (метод `self.canvas.coords(...)` возвращает список координат для заданного объекта). Затем вызывается метод `rect_overlap()`, который определяет, пересекаются ли два прямоугольника.
  4. Если обнаружено пересечение – возвращаем `True`. Если никаких столкновений нет, возвращаем `False`.

### **Метод: `rect_overlap(self, rect1, rect2)`**

```python
def rect_overlap(self, rect1, rect2):
    return not (rect1[2] < rect2[0] or rect1[0] > rect2[2] or
                rect1[3] < rect2[1] or rect1[1] > rect2[3])
```

- **Назначение:**  
  Определяет, пересекаются ли два прямоугольника.  
- **Параметры:**  
  - **`rect1` и `rect2`** – списки координат в формате `[x1, y1, x2, y2]`.
- **Как работает:**  
  Возвращает `True`, если прямоугольники пересекаются. Логика такова: если один прямоугольник находится полностью слева, справа, выше или ниже другого – они не пересекаются. Функция возвращает отрицание этого условия.

### **Метод: `end_game(self)`**

```python
def end_game(self):
    self.game_over = True

    if self.score > self.best_score:
        self.best_score = self.score
        self.save_best_score()

    self.canvas.create_text(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 - 40,
                            text=f"Game Over! Score: {self.score}",
                            font=("Arial", 24), fill="red")
    self.canvas.create_text(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2,
                            text=f"Best: {self.best_score}",
                            font=("Arial", 18), fill="red")
    self.canvas.create_text(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 40,
                            text="Нажмите пробел или клик для рестарта",
                            font=("Arial", 16), fill="red")
```

- **Назначение:**  
  Вызывается, когда происходит столкновение – игра заканчивается.
- **Как работает:**  
  - Устанавливаем флаг `self.game_over` в `True`, чтобы остановить дальнейшие обновления.
  - Если текущий счёт больше сохранённого лучшего, обновляем лучший счёт и сохраняем его в файл.
  - Отображаем на холсте текст «Game Over», текущий и лучший счёт, а также подсказку, как перезапустить игру.

### **Метод: `restart(self)`**

```python
def restart(self):
    self.canvas.delete("all")
    self.score = 0
    self.score_text = self.canvas.create_text(10, 10, anchor="nw",
                                              text=f"Score: {self.score}",
                                              font=("Arial", 16), fill="black")
    self.bird = Bird(self.canvas)
    self.pipes = []
    self.last_pipe_time = time.time() * 1000
    self.game_over = False
    self.update()
```

- **Назначение:**  
  Перезапускает игру после окончания.
- **Как работает:**  
  - **`self.canvas.delete("all")`** удаляет все объекты с холста (тексты, изображения, трубы).
  - Сбрасываем счёт и рисуем новый текст для счёта.
  - Создаём новую птицу и очищаем список труб.
  - Обновляем время для появления труб.
  - Сбрасываем флаг `game_over`.
  - Вызываем `self.update()`, чтобы начать игру заново.

---

## **Как этот файл связан с другими частями кода?**

- **Взаимодействие с `main.py`:**  
  В `main.py` создаётся окно и передаётся в класс `Game` как `root`. Именно с этого окна начинается вся графика.
  
- **Объект птицы (`Bird`):**  
  Создаётся в `self.bird = Bird(self.canvas)`. Класс `Bird` (из файла `bird.py`) отвечает за изображение птицы, её движение, прыжки и получение ограничивающего прямоугольника (`get_bbox()`), который используется для проверки столкновений.
  
- **Объект трубы (`Pipe`):**  
  Каждые несколько секунд создаётся новый объект трубы (`Pipe(self.canvas)`), который добавляется в список `self.pipes`. Эти объекты обновляются (движутся влево) и участвуют в проверке столкновений.
  
- **Константы:**  
  Файл `constants.py` задаёт размеры окна, интервал между трубами и другие настройки, которые используются во всём коде.

- **Обработка ввода:**  
  Метод `handle_input` реагирует на события (нажатия пробела или клики), что позволяет игроку управлять птицей или перезапускать игру после проигрыша.

---

## **Итог**

Файл **game.py** организует всю логику игры:
- **Инициализирует интерфейс** (окно, холст, счёт).
- **Создаёт игровые объекты** (птица и трубы).
- **Обрабатывает ввод пользователя** и обновляет состояние игры в цикле.
- **Проверяет столкновения** и завершает игру, если что-то идёт не так.
- **Позволяет перезапустить игру** после проигрыша.

Все эти части работают вместе, чтобы создать динамичную и интересную игру, где каждое обновление холста – это шаг анимации, а взаимодействие с пользователем делает игру живой.
